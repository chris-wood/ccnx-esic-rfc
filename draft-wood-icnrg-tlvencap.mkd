---
title: CCNx Packet Encapsulation
abbrev: CCNx-PacketEncapsulation
docname: draft-wood-icnrg-packetencap
date: 2015-3-6
category: info

ipr: trust200902
area: General
workgroup: ICNRG Working Group
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: M. Mosko
    name: Marc Mosko
    org: PARC, Inc.
    email: marc.mosko@parc.com
 -
    ins: C. A. Wood
    name: Christopher A. Wood
    org: PARC, Inc.
    email: christopher.wood@parc.com

normative:
    RFC2119:
    CCNxKE:
        target: TODO
        title: TODO
    MESSAGES:
        target: TODO
        title: TODO

informative:
    RFC5389:

--- abstract

This document describes a mechanism to encrypt CCNx TLVs using encapsulation.
CCNx TLVs (e.g., message payloads) are created and then encrypted
and wrapped in a new type of TLV for encapsulation. These wrapper TLVs are
given the new type T_ENCAP. This encapsulation mechanism is used to encrypt
CCNx messages i(i.e., Interests and Content Objects) for transport between
consumers and producers.

--- middle

# Introduction

CCNx messages are designed around authentication, not confidentiality. The
standard CCNx message format includes a fixed header, optional header TLVs,
message body TLV, and optional validation section {{MESSAGES}}. In many applications,
the body of a Content Object (or Interest), i.e., the Payload TLV, are said to be
encrypted for end-to-end confidentiality between a producer and consumer.
However, there does not exist a standard way by which such TLVs are encrypted.

This document specifies a CCNx TLV encapsulation mechanism which can be used
to encrypt any CCNx TLV using standard symmetric-key encryption. Encrypted TLVs,
called TEs (encrypted types), are wrapped in encapsulation TLVs of the type T_ENCAP. These
wrapper TLVs are then inserted into other TLVs for transport. This encapsulation
TLV will be used to an encrypt entire CCNx messages (i.e., Interests or Content Objects)
for transport between a consumer and producer. In this case, the "outer" message TLV, i.e.,
the CCNx message TLV which contains the T_ENCAP internally, is given its own routable CCNx
Name and optional Validation information. The details of which will be specified later in
this document.

The mechanism by which this symmetric key is obtained is outside the scope of
this document; These keys could be pre-shared or derived from an online key-exchange
protocol {{CCNxKE}}.

##  Conventions and Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119 {{RFC2119}}.

The following terms are used:

- Inner TLV: The CCNx message that is encrypted an contained inside a T_ENCAP TLV.
- Outer TLV: The TLV which contains, internally, a T_ENCAP TLV.
- Encapsulation Name: A CCNx Name which can be used to route an encapsulated
CCNx Message and perform decryption.

# Encrypted Types

Encryption of a TLV is done by encapsulation. A new T_ENCAP TLV is created and
used as a security envelope for the plaintext TLV(s). Specifically, the ciphertext
that results from encrypting one or more TLVs is inserted as the value (V) of
the T_ENCAP TLV. This procedure is shown pictorially below.

~~~
+------------------+
| T1 | L1 |   V1   |
+------------------+
         ||
         \/
+----------------------------+
| T2 | L2 |  Enc((T1,L1,V1)) |
+----------------------------+
~~~

In this figure, T1 can be any TLV and T2 is T_ENCAP.

<!-- wrap the value of a plaintext TLV in a new TLV container of type T_ENCAP.  -->

# CCNx Message Encapsulation

To encapsulate an Interest or Content Object, the corresponding CCNx Message TLV
is encapsulated using a T_ENCAP TLV. However, the CCNx Message TLV contains
information such as the packet Name, which is used for routing, it is necessary
to create encapsulation information to transport this (now encrypted) message.
This encapsulation information differs for Interests and Content Objects.

The resulting CCNx Message packet will have a structure similar to the following:

~~~
PACKET := FixedHeader [PerHopHeaders] OuterMessage [Validation]
OuterMessage := EncapsulationName *OuterMetadata InnerMessage
OuterMetadata := ExpiryTime / RecommendedCacheTime / EndChunkNumber
InnerMessage := The encrypted message that is encapsulated in a
                T_ENCAP TLV
Validation := <described in the following sections>
~~~

<!--
TODO: REWRITE ENCRYPTION ALGORITHMS TO STATE THAT AAD INCLUDES EVERYTHING EXCEPT VALIDATIONPAYLOAD.
-->

## Interest Encapsulation

To encrypt an Interest using encapsulation, the outer TLV needs to contain an
Encapsulation Name. The Encapsulation Name must contain at least the following
information:

1. A routable prefix (/prefix/)
2. An identifier for the Encapsulation decryption key and decryption salt.
Specifically, this identifier is a tuple (K, Salt), where K is the decryption key
*KeyId* and *Salt* is the input to the decryption algorithm. The salt is treated
as the IV for the encryption algorithm.

Collectively, the Encapsulation Name conveys the tuple (prefix, K, Salt).
This information is put in the Encapsulation Name because it binds the
decryption key and salt to the encapsulated message. For every encrypted
CCNx Message C there exists at exactly one tuple (K, Salt) that can be used
to decrypt C.

The following algorithm is used to encapsulate an Interest using this approach.

~~~
Input: A plaintext CCNx Message TLV for an Interest I, and tuple
       (prefix, K, Salt).
Output: An Interest I' with the encrypted I inside.

1. Create the Encapsulation Name EN as: /prefix/K/Salt.
2. Create a new Interest I' with the name EN, followed immediately by
   the TLV I contained inside a T_ENCAP TLV.
3. Create and append to I' a ValidationAlgorithm algorithm with the
   T_VALIDATION_ALG type that specifies Interest encapsulation
   (**VALUE TBD**).
4. Encrypt all of I' using AES-GCM. The plaintext for this encryption
   procedure is only the V of the T_ENCAP TLV; The rest of message is
   the AAD. Let (C, T) be the output of this encryption process. Replace
   the V of the T_ENCAP TLV with C.
5. Create and append to I' a ValidationPayload that contains T.
6. Return I'.
~~~

<!--
Interest
Create a T_ENCAP packet
Encapsulation Name
    /routable/prefix/keyid/nonce
    The keyid identifies a (key, salt) pair as before
    The (salt, nonce) makes up the GCM-AES IV
Create an Interest and put it in an encrypted container (TE) after the Name
Add a ValidationAlg and ValidationPayload.  The ValidationAlg identifies that this scheme is being used and is 0-bytes of value.
-->

## Content Object Wrapping

Similar to Interests, an encapsulated Content Object needs an Encapsulation Name.
However, unlike Interests, the actual decryption key identifier, salt, and nonce
are not contained in this Encapsulation Name. This is because the encryption
KeyId, Salt, and Nonce may be different than what was used for the corresponding
Interest (if it was also encrypted). Also, the outer TLV of an encapsulated Content
Object may also include additional cache or control directives that exist outside
of the T_ENCAP wrapper.

The following algorithm is used to encapsulate a Content Object using this approach.

~~~
Input: An Interest I with name N, A plaintext CCNx Message TLV for a
       Content Object CO, and decryption information tuple
       (K, Salt).
Output: A Content Object CO' with the encrypted CO inside.

1. Create the Encapsulation Name EN such that it matches N (the
   Interest Name).
2. Create a new Content Object CO' with the name EN, followed
   immediately by the TLV CO contained inside a T_ENCAP TLV.
3. Create and append to CO' a ValidationAlgorithm algorithm with the
   T_VALIDATION_ALG type that specifies Content Object encapsulation
   (**VALUE TBD**), and a T_KEY_ID value that contains (K, Nonce, Salt).
4. Encrypt all of CO' using AES-GCM. The plaintext for this encryption
   procedure is only the V of the T_ENCAP TLV; The rest of message is
   the AAD. Let (C, T) be the output of this encryption process. Replace
   the V of the T_ENCAP TLV with C.
5. Create and append to CO' a ValidationPayload that contains T.
6. Return CO'.
~~~

<!--
Content Object
Create a T_ENCAP
Encapsulation Name: matches Interest name
Put the response ContentObject in a TE (likely different number than the Interest).
Add a ValidationAlg with (KeyId, Nonce) used by the TE and ValidationPayload with the auth tag.
This ValidationAlg indicates that the KeyId/Nonce in the Name is not what is being used (unless they are equal).
One may put plaintext cache control directives (or other TLVs) in the T_ENCAP outside the encryption envelope.
-->

# Security Considerations

TODO.

--- back

# Test Vectors

## Sample Encryption TLVs

TODO

## Interest Encapsulation Examples

TODO

## Content Object Encapsulation Examples

TODO
